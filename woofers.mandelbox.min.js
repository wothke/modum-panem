/*
* Based on original "mandelbox" logic from "old version" of Fractal Lab (see http://www.subblue.com). 
*
* Copyright 2011, Tom Beddard
* http://www.subblue.com
*
* Added THREE.js integration, base for 'god's ray' lighting, 'depthbuffer' and 
* 'poor mann's collision detection' handling.
* Requires the following WEBGL extensions: GL_EXT_draw_buffers, GL_EXT_frag_depth
*
* Copyright 2017, Juergen Wothke
*
* Licensed under the GPL Version 3 license.
* http://www.gnu.org/licenses/
*/
function getMandelboxMaterial(a,b,c,d,e,f,g){var h={uniforms:{waterworld:{type:"f",value:0},bubble_origin:{type:"v2",value:new THREE.Vector2(0,0)},bubble_radius:{type:"f",value:0},deFactor:{type:"f",value:1},scale:{type:"f",value:-2.81},surfaceDetail:{type:"f",value:.66},surfaceSmoothness:{type:"f",value:.79},boundingRadius:{type:"f",value:114.02},offset:{type:"v3",value:new THREE.Vector3(0,0,0)},cameraPitch:{type:"f",value:e.x},cameraYaw:{type:"f",value:e.y},cameraRoll:{type:"f",value:e.z},cameraFocalLength:{type:"f",value:.9},cameraPosition:{type:"v3",value:d},sCount:{type:"colorIterations",value:3},color1:{type:"v3",value:new THREE.Vector3(.4,.3,.9)},color1Intensity:{type:"f",value:2.946},color2:{type:"v3",value:new THREE.Vector3(.1,.1803921568627451,.1)},color2Intensity:{type:"f",value:.16},color3:{type:"v3",value:new THREE.Vector3(.3,.3,.9)},color3Intensity:{type:"f",value:.11},transparent:{value:!1},gamma:{type:"f",value:.799},light:{type:"v3",value:new THREE.Vector3(48,191,-198)},ambientColor:{type:"v2",value:new THREE.Vector2(.41,0)},background1Color:{type:"v3",value:c},background2Color:{type:"v3",value:new THREE.Vector3(0,0,0)},innerGlowColor:{type:"v3",value:new THREE.Vector3(.23,.249,.9019)},innerGlowIntensity:{type:"f",value:.24},outerGlowColor:{type:"v3",value:new THREE.Vector3(1,1,1)},outerGlowIntensity:{type:"f",value:.08},fog:{type:"f",value:.06},fogFalloff:{type:"f",value:2.8},specularity:{type:"f",value:.86},specularExponent:{type:"f",value:7},size:{type:"v2",value:new THREE.Vector2(a/2,b/2)},outputSize:{type:"v2",value:new THREE.Vector2(a,b)},aoIntensity:{type:"f",value:.21},aoSpread:{type:"f",value:11.79},sphereScale:{type:"f",value:1},boxScale:{type:"f",value:.5},boxFold:{type:"f",value:1},fudgeFactor:{type:"f",value:0}},vertexShader:["#extension GL_EXT_draw_buffers : require","#extension GL_EXT_frag_depth : enable","precision mediump float;","attribute vec4 position;","void main()\t{","  gl_Position = position;","}"].join("\n"),fragmentShader:["#extension GL_EXT_draw_buffers : require","#extension GL_EXT_frag_depth : enable","#ifdef GL_ES","precision mediump float;","#endif","#define HALFPI 1.570796","#define MIN_EPSILON 6e-7","#define MIN_NORM 1.5e-7","#define maxIterations 15","#define stepLimit 105","#define aoIterations 3","#define minRange 6e-5","uniform float waterworld;","uniform vec2 bubble_origin;","uniform float bubble_radius;","uniform float deFactor;","uniform sampler2D tDepth;","uniform float scale;","uniform float surfaceDetail;","uniform float surfaceSmoothness;","uniform float boundingRadius;","uniform vec3  offset;","uniform float cameraRoll;","uniform float cameraPitch;","uniform float cameraYaw;","uniform float cameraFocalLength;","uniform vec3  cameraPosition;","uniform int   colorIterations;","uniform vec3  color1;","uniform float color1Intensity;","uniform vec3  color2;","uniform float color2Intensity;","uniform vec3  color3;","uniform float color3Intensity;","uniform bool  transparent;","uniform float gamma;","uniform vec3  light;","uniform vec2  ambientColor;","uniform vec3  background1Color;","uniform vec3  background2Color;","uniform vec3  innerGlowColor;","uniform float innerGlowIntensity;","uniform vec3  outerGlowColor;","uniform float outerGlowIntensity;","uniform float fog;","uniform float fogFalloff;","uniform float specularity;","uniform float specularExponent;","uniform vec2  size;","uniform vec2  outputSize;","uniform float aoIntensity;","uniform float aoSpread;","float aspectRatio = outputSize.x / outputSize.y;","float fovfactor = 1.0 / sqrt(1.0 + cameraFocalLength * cameraFocalLength);","float pixelScale = 1.0 / min(outputSize.x, outputSize.y);","float epsfactor = 2.0 * fovfactor * pixelScale * surfaceDetail;","vec3  w = vec3(0, 0, 1);","vec3  v = vec3(0, 1, 0);","vec3  u = vec3(1, 0, 0);","mat3  cameraRotation;","mat3 rotationMatrixVector(vec3 v, float angle)","{","    float c = cos(radians(angle));","    float s = sin(radians(angle));","    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,","              (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,","              (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);","}","uniform float sphereScale;","uniform float boxScale;","uniform float boxFold;","uniform float fudgeFactor;","float mR2 = boxScale * boxScale;","float fR2 = sphereScale * mR2;","vec2  scaleFactor = vec2(scale, abs(scale)) / mR2;","vec3 Mandelbox(vec3 w)","{","    float md = 1000.0;","    vec3 c = w;","    vec4 p = vec4(w.xyz, deFactor),","        p0 = vec4(w.xyz, 1.0);","    for (int i = 0; i < int(maxIterations); i++) {","        p.xyz = clamp(p.xyz, -boxFold, boxFold) * 2.0 * boxFold - p.xyz;","        float d = dot(p.xyz, p.xyz);","        p.xyzw *= clamp(max(fR2 / d, mR2), 0.0, 1.0);","        p.xyzw = p * scaleFactor.xxxy + p0 + vec4(offset, 0.0);","        if (i < colorIterations) {","            md = min(md, d);","            c = p.xyz;","        }","    }","    return vec3((length(p.xyz) - fudgeFactor) / p.w, md, 0.33 * log(dot(c, c)) + 1.0);","}","vec3 rayDirection(vec2 pixel)","{","    vec2 p = (0.5 * size - pixel) / vec2(size.x, -size.y);","    p.x *= aspectRatio;","    vec3 d = (p.x * u + p.y * v - cameraFocalLength * w);","    return normalize(cameraRotation * d);","}","bool intersectBoundingSphere(vec3 origin,","                             vec3 direction,","                             out float tmin,","                             out float tmax)","{","    bool hit = false;","    float b = dot(origin, direction);","    float c = dot(origin, origin) - boundingRadius;","    float disc = b*b - c;","    tmin = tmax = 0.0;","    if (disc > 0.0) {","        float sdisc = sqrt(disc);","        float t0 = -b - sdisc;","        float t1 = -b + sdisc;","        if (t0 >= 0.0) {","            tmin = t0;","            tmax = t0 + t1;","        } else {","            tmax = t1;","        }","        hit = true;","    }","    return hit;","}","vec3 generateNormal(vec3 z, float d)","{","    float e = max(d * 0.5, MIN_NORM);","    float dx1 = Mandelbox(z + vec3(e, 0, 0)).x;","    float dx2 = Mandelbox(z - vec3(e, 0, 0)).x;","    float dy1 = Mandelbox(z + vec3(0, e, 0)).x;","    float dy2 = Mandelbox(z - vec3(0, e, 0)).x;","    float dz1 = Mandelbox(z + vec3(0, 0, e)).x;","    float dz2 = Mandelbox(z - vec3(0, 0, e)).x;","    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));","}","vec3 blinnPhong(vec3 color, vec3 p, vec3 n)","{","    vec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);","    ambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);","    vec3  halfLV = normalize(light - p);","    float diffuse = max(dot(n, halfLV), 0.0);","    float specular = pow(diffuse, specularExponent);","    return ambColor * color + color * diffuse + specular * specularity;","}","float ambientOcclusion(vec3 p, vec3 n, float eps)","{","    float o = 1.0;","    eps *= aoSpread;","    float k = aoIntensity / eps;","    float d = 2.0 * eps;","    for (int i = 0; i < aoIterations; ++i) {","        o -= (d - Mandelbox(p + n * d).x) * k;","        d += eps;","        k *= 0.5;","    }","    return clamp(o, 0.0, 1.0);","}","vec4 render(vec2 pixel)","{","    vec3  ray_direction = rayDirection(pixel);","    float ray_length = minRange;","    vec3  ray = cameraPosition + ray_length * ray_direction;","    vec4  bg_color = vec4(clamp(mix(background2Color, background1Color, (sin(ray_direction.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0), 1.0);","    vec4  color = bg_color;","    float eps = MIN_EPSILON;","    vec3  dist;","    vec3  normal = vec3(0);","    int   steps = 0;","    bool  hit = false;","    float tmin = 0.0;","    float tmax = 0.0;","\t bool useAttachment= false;","\t vec4 attachmenColor= vec4(0.,0.,0.,1.);","    if (intersectBoundingSphere(ray, ray_direction, tmin, tmax)) {","\t\tfloat omin = tmin;","\t\tif (0. < bubble_radius) {","\t\t\tvec2 v= bubble_origin - vec2(pixel.x/outputSize.x, pixel.y/outputSize.y);","\t\t\tv.x*= outputSize.x/outputSize.y;","\t\t\tfloat di = length(v);","\t\t\tif (di <= bubble_radius) {","\t\t\t\tfloat depth=(sin((1.-(di/bubble_radius))*HALFPI))*0.01;","\t\t\t\tif (tmin < depth) {","\t\t\t\t\ttmin+= (depth*0.03);","\t\t\t\t} ","\t\t\t} ","\t\t} ","        ray_length = tmin;","        ray = cameraPosition + ray_length * ray_direction;","\t   \tvec3  lastDist= vec3(0.,0.,0.);","        for (int i = 0; i < stepLimit; i++) {","            steps = i;","            dist = Mandelbox(ray);","            dist.x *= surfaceSmoothness;","            if (hit && dist.x < eps || ray_length > tmax || ray_length < tmin) {","                steps--;","\t\t\t\tif ( (tmin != omin) &&  (dist == lastDist)) {","\t\t \t\t\tuseAttachment= true;","\t \t\t\t\tattachmenColor.b= 1.;","       \t\t}","                break;","            }","            hit = false;","            ray_length += dist.x;","            ray = cameraPosition + ray_length * ray_direction;","            eps = ray_length * epsfactor;","\t\t\tif (ray_length > 0.1) {","\t\t\t\tray_length+=waterworld;","\t\t\t\thit = true;","\t\t\t} else ","           if (dist.x < eps || ray_length < tmin) {","               hit = true;","\t\t\t\tlastDist= dist;","       \t}","    \t}","    }","    float glowAmount = float(steps)/float(stepLimit);","    float glow;","    if (hit) {","        float aof = 1.0, shadows = 1.0;","        glow = clamp(glowAmount * innerGlowIntensity * 3.0, 0.0, 1.0);","        if (steps < 1 || ray_length < tmin) {","            normal = normalize(ray);","        } else {","            normal = generateNormal(ray, eps);","            aof = ambientOcclusion(ray, normal, eps);","        }","        color.rgb = mix(color1, mix(color2, color3, dist.y * color2Intensity), dist.z * color3Intensity);","        color.rgb = blinnPhong(clamp(color.rgb * color1Intensity, 0.0, 1.0), ray, normal);","        color.rgb *= aof;","        color.rgb = mix(color.rgb, innerGlowColor, glow);","        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0) * fog));","        color.a = 1.0;","    } else {","        ray_length = tmax;","        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0)) * fog);","        glow = clamp(glowAmount * outerGlowIntensity * 3.0, 0.0, 1.0);","        color.rgb = mix(color.rgb, outerGlowColor, glow);","\t\tattachmenColor.g = 1.;","\t\tuseAttachment= true;","        if (transparent) color = vec4(0.0);","    }","    gl_FragDepthEXT = 0.5+ray_length*1.0;","    if (useAttachment) gl_FragData[1] = attachmenColor;","    return color;","}","void main()","{","    vec4 color = vec4(0.0);","    float n = 0.0;","    cameraRotation = rotationMatrixVector(u, cameraPitch)*rotationMatrixVector(v, cameraYaw) * rotationMatrixVector(w, cameraRoll);","    color = render(gl_FragCoord.xy);","   gl_FragData[0] = vec4(pow(abs(color.rgb), vec3(1.0 / gamma)), color.a);","}"].join("\n")},i=new THREE.RawShaderMaterial({uniforms:THREE.UniformsUtils.clone(h.uniforms),vertexShader:h.vertexShader,fragmentShader:h.fragmentShader});return i.uniforms.bubble_origin.value=f,i.uniforms.bubble_radius.value=g,i.uniforms.cameraPitch.value=e.x,i.uniforms.cameraYaw.value=e.y,i.uniforms.cameraRoll.value=e.z,i}